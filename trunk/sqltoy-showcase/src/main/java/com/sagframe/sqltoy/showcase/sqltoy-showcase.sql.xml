<?xml version="1.0" encoding="utf-8"?>
<sqltoy xmlns="http://www.sagframe.com/schema/sqltoy"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.sagframe.com/schema/sqltoy http://www.sagframe.com/schema/sqltoy/sqltoy.xsd">
	<!-- 演示分库 -->
	<sql id="sqltoy_db_sharding_case">
		<sharding-datasource
			strategy="hashBalanceDBSharding" params="userId" />
		<value>
			<![CDATA[
			select * from sqltoy_user_log t 
			-- userId 作为分库关键字段属于必备条件
			where t.user_id=:userId 
			#[and t.log_date>=:beginDate]
			#[and t.log_date<=:endDate]
				]]>
		</value>
	</sql>

	<!-- 演示分表 -->
	<sql id="sqltoy_15d_table_sharding_case">
		<sharding-table tables="sqltoy_trans_info_15d"
			strategy="historyTableStrategy" params="beginDate" />
		<value>
			<![CDATA[
			select * from sqltoy_trans_info_15d t 
			where t.trans_date>=:beginDate
			#[and t.trans_date<=:endDate]
				]]>
		</value>
	</sql>

	<!-- 演示树形表递归查询 -->
	<sql id="sqltoy_treeTable_search">
		<value>
			<![CDATA[
			select * from sqltoy_organ_info t 
			where exists 
			(
				select 1 from sqltoy_organ_info t1 
				where t1.ORGAN_ID=t.ORGAN_ID
				and instr(t1.NODE_ROUTE,:nodeRoute)
			)
				]]>
		</value>
	</sql>

	<!-- 快速分页和分页优化演示 -->
	<sql id="sqltoy_fastPage">
		<!-- 分页优化器,通过缓存实现查询条件一致的情况下在一定时间周期内缓存总记录数量，从而无需每次查询总记录数量 -->
		<!-- alive-max:最大存放多少个不同查询条件的总记录量; alive-seconds:查询条件记录量存活时长(比如120秒,超过阀值则重新查询) -->
		<page-optimize alive-max="100" alive-seconds="120" />
		<value>
			<![CDATA[
			select t1.*,t2.ORGAN_NAME 
			-- @fast() 实现先分页取10条(具体数量由pageSize确定),然后再进行管理
			from @fast(select t.*
			           from sqltoy_staff_info t
			           where t.STATUS=1 
			             #[and t.STAFF_NAME like :staffName] 
			           order by t.ENTRY_DATE desc
			            ) t1 
			left join sqltoy_organ_info t2 on  t1.organ_id=t2.ORGAN_ID
				]]>
		</value>
		<!-- 这里为极特殊情况下提供了自定义count-sql来实现极致性能优化 -->
		<!-- <count-sql></count-sql> -->
	</sql>


	<!-- 
	       综合查询缓存翻译、缓存条件过滤演示： 
	   1)通过缓存将代码转化为名称，避免关联查询，极大简化sql并提升查询效率 
	   2)通过缓存名称模糊匹配获取精准的编码作为条件，避免关联like 模糊查询
	 -->
	<sql id="sqltoy_order_search">
		<translate cache="dictKeyNameCache" cache-type="" columns="deviceTypeName" />
		<!--  -->
		<translate cache="staffIdNameCache" columns="staffName" />
		<translate cache="organIdNameCache" columns="organName" />
		<filters>
			<cache-arg cache-name="" param="">
				<!-- 这里的filter是排除的概念,将符合条件的排除掉 -->
				<filter compare-param="" cache-index="" />
			</cache-arg>
		</filters>
		<value>
			<![CDATA[
			select 	ORDER_ID,
					DEVICE_TYPE,
					DEVICE_TYPE deviceTypeName,-- 设备分类名称
					PS_TYPE,
					PS_TYPE as psTypeName, -- 购销类别名称
					TOTAL_CNT,
					TOTAL_AMT,
					BUYER,
					SALER,
					TRANS_DATE,
					DELIVERY_TERM,
					STAFF_ID,
					STAFF_ID staffName, -- 员工姓名
					ORGAN_ID,
					ORGAN_ID organName, -- 机构名称
					CREATE_BY,
					CREATE_TIME,
					UPDATE_BY,
					UPDATE_TIME,
					STATUS,
					STATUS statusName -- 状态名称
			from sqltoy_device_order_info t 
			where #[t.ORDER_ID=:orderId]
			      -- 当前用户能够访问的授权组织机构，控制数据访问权限(一般登录后直接放于用户session中)
				  #[and t.ORGAN_ID in (:authedOrganIds)]
				  #[and t.STAFF_ID in (:staffIds)]
				  #[and t.TRANS_DATE>=:beginDate]
				  #[and t.TRANS_DATE<=:endDate]
				]]>
		</value>
	</sql>
</sqltoy>